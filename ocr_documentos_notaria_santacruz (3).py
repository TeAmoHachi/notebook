# -*- coding: utf-8 -*-
"""OCR_Documentos_Notaria_SantaCruz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vX6Isw03ZvRfhaZWwNooq1FE9KYwmLeg
"""

"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”¥ SISTEMA OCR INTELIGENTE PARA NOTARÃA SANTA CRUZ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Autor: TeAmoHachi
Fecha: 2025-01-14
VersiÃ³n: 1.0

DOCUMENTOS SOPORTADOS:
âœ… DNI Azul (formato antiguo)
âœ… DNI ElectrÃ³nico (formato nuevo)
âœ… Carnet de ExtranjerÃ­a
âœ… Pasaporte Peruano
âœ… Pasaporte Extranjero

REQUISITOS:
- Google Colab Pro (GPU activada)
- Python 3.10+
- PaddleOCR
- OpenCV

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 1: VERIFICAR GPU (Colab Pro)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import subprocess
import sys

print("ğŸ” Verificando GPU disponible...")
print("=" * 70)

# Verificar NVIDIA GPU
try:
    gpu_info = subprocess.check_output(['nvidia-smi'], encoding='utf-8')
    print("âœ… GPU DETECTADA:")
    print(gpu_info)
except:
    print("âš ï¸ NO SE DETECTÃ“ GPU")
    print("ğŸ’¡ SOLUCIÃ“N:")
    print("   1. Ve a: Entorno de ejecuciÃ³n â†’ Cambiar tipo de entorno")
    print("   2. Selecciona: Acelerador de hardware â†’ T4 GPU")
    print("   3. Guarda y vuelve a ejecutar esta celda")
    sys.exit(1)

print("\nâœ… GPU lista para usar")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 2: INSTALAR DEPENDENCIAS (VERSIONES FIJAS Y ESTABLES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ Instalando librerÃ­as con versiones compatibles...")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 1: LIMPIAR INSTALACIONES PREVIAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ§¹ Limpiando instalaciones previas...")
!pip uninstall -y -q paddlepaddle paddlepaddle-gpu paddleocr paddlex 2>/dev/null
print("   âœ… Limpieza completada")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 2: INSTALAR NUMPY CORRECTO (CRÃTICO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando NumPy 1.26.4 (compatible)...")
!pip install -q "numpy<2.0" --force-reinstall
print("   âœ… NumPy 1.26.4 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 3: INSTALAR PADDLEPADDLE 2.6.1 (VERSIÃ“N ESTABLE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddlePaddle 2.6.1...")
!pip install -q paddlepaddle-gpu==2.6.1
print("   âœ… PaddlePaddle 2.6.1 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 4: INSTALAR PADDLEOCR 2.7.3 (COMPATIBLE CON 2.6.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddleOCR 2.7.3...")
!pip install -q paddleocr==2.7.3
print("   âœ… PaddleOCR 2.7.3 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 5: INSTALAR DEPENDENCIAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando OpenCV y dependencias...")
!pip install -q opencv-python-headless pillow shapely
print("   âœ… OpenCV instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 6: REINICIAR KERNEL (OBLIGATORIO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("âœ… INSTALACIÃ“N COMPLETADA")
print("=" * 70)

print("\nğŸ”„ REINICIANDO KERNEL...")
print("   â±ï¸ Se reiniciarÃ¡ en 3 segundos...")
print("\nğŸ’¡ DESPUÃ‰S DEL REINICIO (mensaje 'session crashed'):")
print("   1. Click en RECONNECT")
print("   2. Ejecuta celda 1 (verificar GPU)")
print("   3. Ejecuta celda 2B (verificaciÃ³n)")
print("   4. Ejecuta celda 3 (inicializar OCR)")

import time
time.sleep(3)

import os
os.kill(os.getpid(), 9)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2A: INSTALAR NUMPY Y REINICIAR (PASO 1 de 2)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ PASO 1: Instalando NumPy correcto...")
print("=" * 70)

# Limpiar versiones conflictivas
print("\nğŸ§¹ Limpiando NumPy anterior...")
!pip uninstall -y -q numpy 2>/dev/null

# Instalar NumPy 1.26.4
print("\nğŸ”§ Instalando NumPy 1.26.4...")
!pip install -q "numpy==1.26.4"

# Verificar instalaciÃ³n
import numpy as np
print(f"\nâœ… NumPy instalado: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âš ï¸ VersiÃ³n incorrecta, reintentando...")
    !pip install --force-reinstall -q "numpy==1.26.4"

print("\n" + "=" * 70)
print("âœ… NUMPY 1.26.4 INSTALADO")
print("=" * 70)

print("\nğŸ”„ REINICIANDO KERNEL...")
print("   Esto es OBLIGATORIO para que NumPy se cargue correctamente")
print("\nğŸ’¡ DESPUÃ‰S DEL REINICIO:")
print("   1. Click en RECONNECT")
print("   2. âš ï¸ NO ejecutes celda 2A de nuevo")
print("   3. âœ… Ejecuta celda 2B (instalar PaddleOCR)")

import time
time.sleep(3)

import os
os.kill(os.getpid(), 9)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2B: INSTALAR PADDLEOCR (VERSIÃ“N MEJORADA - congela NumPy)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ PASO 2: Instalando PaddleOCR con NumPy congelado...")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Verificar NumPy inicial
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
print(f"\nğŸ” NumPy inicial: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âŒ ERROR: NumPy incorrecto")
    print("   Ejecuta celda 2A y reinicia nuevamente")
    raise Exception("NumPy incorrecto")
else:
    print("   âœ… NumPy 1.26.4 correcto")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Crear constraints.txt para BLOQUEAR NumPy
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”’ Creando restricciones para evitar upgrade de NumPy...")

with open('/tmp/constraints.txt', 'w') as f:
    f.write('numpy==1.26.4\n')
    f.write('scipy<1.14.0\n')  # VersiÃ³n compatible con NumPy 1.x

print("   âœ… Restricciones creadas")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Instalar PaddlePaddle (sin dependencias)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddlePaddle 2.6.1...")
!pip install -q --no-deps paddlepaddle-gpu==2.6.1
!pip install -q -c /tmp/constraints.txt protobuf decorator astor
print("   âœ… PaddlePaddle instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Instalar PaddleOCR (con restricciones de NumPy)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddleOCR 2.7.3 con restricciones...")
!pip install -q --no-deps paddleocr==2.7.3
!pip install -q -c /tmp/constraints.txt \
    opencv-python-headless pillow shapely pyclipper lmdb tqdm \
    rapidfuzz pyyaml attrdict scipy scikit-image imgaug

print("   âœ… PaddleOCR instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Verificar que NumPy NO cambiÃ³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ” Verificando que NumPy no cambiÃ³...")
import importlib
importlib.reload(np)
import numpy as np

print(f"   NumPy final: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âŒ NumPy cambiÃ³ a 2.x")
    print("   Forzando downgrade...")
    !pip install --force-reinstall -q "numpy==1.26.4"
    print("   âœ… NumPy restaurado")
else:
    print("   âœ… NumPy se mantuvo en 1.26.4")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VerificaciÃ³n final
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("ğŸ” VERIFICANDO INSTALACIÃ“N FINAL")
print("=" * 70)

try:
    import paddle
    print(f"\nâœ… PaddlePaddle: {paddle.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

try:
    import paddleocr
    print(f"âœ… PaddleOCR: {paddleocr.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

try:
    import cv2
    print(f"âœ… OpenCV: {cv2.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

print(f"âœ… NumPy: {np.__version__}")

print("\n" + "=" * 70)
print("âœ… INSTALACIÃ“N COMPLETA")
print("=" * 70)
print("\nğŸ’¡ Ahora ejecuta la celda 3 (Inicializar OCR)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2C: ARREGLAR SCIPY (opcional, solo si celda 3 falla)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ”§ Arreglando scipy...")

# Desinstalar scipy corrupto
!pip uninstall -y scipy 2>/dev/null

# Reinstalar scipy compatible con NumPy 1.26.4
!pip install -q "scipy==1.11.4"

print("âœ… Scipy reinstalado")

# Verificar
try:
    import scipy
    print(f"âœ… Scipy: {scipy.__version__}")
except Exception as e:
    print(f"âš ï¸ Scipy sigue con error: {e}")
    print("   Pero PaddleOCR puede funcionar igual")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 3: INICIALIZAR OCR (compatible con PaddleOCR 2.7.3)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ¤– Inicializando motor OCR...")
print("=" * 70)
print("â±ï¸ Descargando modelos (solo la primera vez)...\n")

from paddleocr import PaddleOCR

# ConfiguraciÃ³n compatible con PaddleOCR 2.7.3
ocr_engine = PaddleOCR(
    use_angle_cls=True,  # Detectar orientaciÃ³n
    lang='es'            # Idioma espaÃ±ol
)

print("\nâœ… Motor OCR listo")
print("   ğŸ‡ªğŸ‡¸ Idioma: EspaÃ±ol")
print("   ğŸ¯ VersiÃ³n 2.7.3 (estable)")
print("   âš¡ GPU activada automÃ¡ticamente")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES AUXILIARES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extraer_texto_limpio(resultado_ocr):
    """
    Convierte el resultado de PaddleOCR a texto plano limpio

    Args:
        resultado_ocr: Output de ocr.ocr()

    Returns:
        str: Texto extraÃ­do limpio
    """
    if not resultado_ocr or not resultado_ocr[0]:
        return ""

    lineas = []
    for linea in resultado_ocr[0]:
        texto = linea[1][0]  # [1][0] = texto detectado
        confianza = linea[1][1]  # [1][1] = confianza (0-1)

        # Solo incluir texto con confianza > 60%
        if confianza > 0.6:
            lineas.append(texto)

    return "\n".join(lineas)


def mostrar_resultado_ocr(resultado_ocr, titulo="Texto ExtraÃ­do"):
    """
    Muestra el resultado del OCR de forma bonita
    """
    print(f"\n{'=' * 70}")
    print(f"ğŸ“„ {titulo}")
    print(f"{'=' * 70}\n")

    if not resultado_ocr or not resultado_ocr[0]:
        print("âŒ No se detectÃ³ texto")
        return

    for i, linea in enumerate(resultado_ocr[0], 1):
        texto = linea[1][0]
        confianza = linea[1][1]

        # Color segÃºn confianza
        if confianza > 0.9:
            emoji = "âœ…"
        elif confianza > 0.7:
            emoji = "âš ï¸"
        else:
            emoji = "âŒ"

        print(f"{emoji} [{confianza*100:5.1f}%] {texto}")

    print(f"\n{'=' * 70}")


def mejorar_imagen_para_ocr(imagen):
    """
    Mejora fotocopias y fotos de baja calidad

    Aplica:
    - ConversiÃ³n a escala de grises
    - Aumento de contraste (CLAHE)
    - ReducciÃ³n de ruido
    - BinarizaciÃ³n adaptativa
    - Aumento de nitidez

    Args:
        imagen: numpy array (BGR)

    Returns:
        numpy array: Imagen mejorada
    """
    # 1) Convertir a escala de grises
    if len(imagen.shape) == 3:
        gray = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gray = imagen

    # 2) Aumentar contraste (hace el texto mÃ¡s visible)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(gray)

    # 3) Reducir ruido (suaviza manchas de fotocopia)
    denoised = cv2.fastNlMeansDenoising(enhanced, h=10)

    # 4) BinarizaciÃ³n adaptativa (texto negro sobre blanco)
    binary = cv2.adaptiveThreshold(
        denoised,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        11,
        2
    )

    # 5) Aumentar nitidez
    kernel = np.array([[-1, -1, -1],
                       [-1,  9, -1],
                       [-1, -1, -1]])
    sharpened = cv2.filter2D(binary, -1, kernel)

    return sharpened


def cargar_imagen(ruta_o_bytes):
    """
    Carga imagen desde archivo o bytes

    Args:
        ruta_o_bytes: str (ruta) o bytes (archivo subido)

    Returns:
        numpy array: Imagen en formato BGR
    """
    if isinstance(ruta_o_bytes, str):
        # Es una ruta de archivo
        imagen = cv2.imread(ruta_o_bytes)
    else:
        # Es bytes (archivo subido en Streamlit/Colab)
        imagen = cv2.imdecode(
            np.frombuffer(ruta_o_bytes.read(), np.uint8),
            cv2.IMREAD_COLOR
        )

    return imagen


def detectar_calidad_imagen(imagen):
    """
    EvalÃºa la calidad de la imagen

    Returns:
        dict: {
            "contraste": float,
            "nitidez": float,
            "es_fotocopia": bool,
            "calidad": str ("EXCELENTE" | "BUENA" | "REGULAR" | "MALA")
        }
    """
    # Convertir a gris si es necesario
    if len(imagen.shape) == 3:
        gray = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gray = imagen

    # Calcular contraste (desviaciÃ³n estÃ¡ndar)
    contraste = gray.std()

    # Calcular nitidez (Laplacian variance)
    laplacian = cv2.Laplacian(gray, cv2.CV_64F)
    nitidez = laplacian.var()

    # Determinar si es fotocopia (bajo contraste)
    es_fotocopia = contraste < 50

    # Clasificar calidad
    if contraste > 60 and nitidez > 500:
        calidad = "EXCELENTE"
    elif contraste > 45 and nitidez > 300:
        calidad = "BUENA"
    elif contraste > 30:
        calidad = "REGULAR"
    else:
        calidad = "MALA"

    return {
        "contraste": contraste,
        "nitidez": nitidez,
        "es_fotocopia": es_fotocopia,
        "calidad": calidad
    }


print("âœ… Funciones auxiliares cargadas")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DETECTORES DE TIPO DE DOCUMENTO (VERSIÃ“N MEJORADA)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re

def limpiar_texto_ocr(texto):
    """
    Limpia texto del OCR para mejorar detecciÃ³n
    - Elimina espacios extra
    - Normaliza caracteres especiales
    - Convierte a mayÃºsculas
    """
    # MayÃºsculas
    texto = texto.upper()

    # Reemplazar caracteres similares
    texto = texto.replace('Ãš', 'U')
    texto = texto.replace('Ã‰', 'E')
    texto = texto.replace('Ã', 'A')
    texto = texto.replace('Ã', 'I')
    texto = texto.replace('Ã“', 'O')
    texto = texto.replace('Ã‘', 'N')

    # Eliminar espacios mÃºltiples
    texto = re.sub(r'\s+', ' ', texto)

    return texto


def detectar_tipo_documento(texto_ocr):
    """
    Detecta el tipo de documento automÃ¡ticamente (VERSIÃ“N MEJORADA)

    Mejoras:
    - BÃºsqueda flexible (sin acentos, sin espacios exactos)
    - Scoring ponderado (mÃºltiples palabras clave)
    - Maneja errores comunes del OCR
    """
    texto = limpiar_texto_ocr(texto_ocr)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PALABRAS CLAVE POR TIPO (sin acentos, flexibles)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    patterns = {
        "DNI_AZUL": {
            "palabras": [
                "DOCUMENTO NACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONALDE IDENTIDAD",  # Sin espacios
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",  # Sin espacio
                "CUI",
                "CONSTANCIA DE SUFRAGIO",
                "CONSTANCIADE SUFRAGIO"
            ],
            "score_minimo": 3  # Necesita al menos 3 matches
        },

        "DNI_ELECTRONICO": {
            "palabras": [
                "DOCUMENTO NACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONALDE IDENTIDAD",
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",
                "REGISTRO NACIONAL",
                "REGISTRONACIONAL",
                "CUI",
                "PRIMER APELLIDO",
                "PRIMERAPELLIDO",
                "SEGUNDO APELLIDO",
                "SEGUNDOAPELLIDO",
                "PRENOMBRES",
                "CONSTANCIA",
                # NO debe tener estas palabras (diferenciador)
                "!SUPERINTENDENCIA"  # ! = NO debe estar
            ],
            "score_minimo": 4
        },

        "CARNET_EXTRANJERIA": {
            "palabras": [
                "SUPERINTENDENCIA NACIONAL DE MIGRACIONES",
                "SUPERINTENDENCIANACIONAL DEMIGRACIONES",
                "CARNE DE EXTRANJERIA",
                "CARNEDE EXTRANJERIA",
                "CALIDAD MIGRATORIA",
                "CALIDADMIGRATORIA",
                "MIGRACIONES PERU",
                "MIGRACIONESPERU"
            ],
            "score_minimo": 2
        },

        "PASAPORTE_PERUANO": {
            "palabras": [
                "PASSPORT",
                "PASAPORTE",
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",
                "P<PER",
                "TYPE P",
                "TIPO P"
            ],
            "score_minimo": 2
        },

        "PASAPORTE_EXTRANJERO": {
            "palabras": [
                "PASSPORT",
                "PASSEPORT",
                "P<USA", "P<ESP", "P<ARG", "P<COL", "P<VEN",
                "P<CHL", "P<BRA", "P<ECU", "P<BOL", "P<MEX"
            ],
            "score_minimo": 1
        }
    }

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CALCULAR SCORES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    scores = {}

    for tipo, config in patterns.items():
        score = 0

        for palabra in config["palabras"]:
            # Palabras negativas (no deben estar)
            if palabra.startswith("!"):
                palabra_limpia = palabra[1:]
                if palabra_limpia in texto:
                    score -= 10  # PenalizaciÃ³n fuerte
            else:
                # Palabras positivas (deben estar)
                if palabra in texto:
                    score += 1

        scores[tipo] = score

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DETERMINAR TIPO GANADOR
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Ordenar por score
    tipos_ordenados = sorted(scores.items(), key=lambda x: x[1], reverse=True)

    mejor_tipo, mejor_score = tipos_ordenados[0]
    score_minimo = patterns[mejor_tipo]["score_minimo"]

    # Verificar si cumple el mÃ­nimo
    if mejor_score >= score_minimo:

        # Mapear colores y formatos
        info_tipos = {
            "DNI_AZUL": {
                "formato": "ANTIGUO",
                "color": "AZUL_TURQUESA",
                "pais": "PERU"
            },
            "DNI_ELECTRONICO": {
                "formato": "NUEVO",
                "color": "BEIGE_CREMA",
                "pais": "PERU"
            },
            "CARNET_EXTRANJERIA": {
                "formato": "MIGRACIONES",
                "color": "ROSA_AMARILLO",
                "pais": "PERU"
            },
            "PASAPORTE_PERUANO": {
                "formato": "PASAPORTE",
                "color": "VINO_TINTO",
                "pais": "PERU"
            },
            "PASAPORTE_EXTRANJERO": {
                "formato": "PASAPORTE",
                "color": "VARIA",
                "pais": "EXTRANJERO"
            }
        }

        info = info_tipos[mejor_tipo]
        confianza = min(mejor_score / (score_minimo + 2), 1.0)  # Normalizar 0-1

        return {
            "tipo": mejor_tipo,
            "formato": info["formato"],
            "color": info["color"],
            "pais": info["pais"],
            "confianza": confianza,
            "score": mejor_score,
            "debug_scores": scores  # Para debugging
        }

    # No se pudo identificar
    return {
        "tipo": "DESCONOCIDO",
        "formato": None,
        "color": None,
        "pais": None,
        "confianza": 0.0,
        "score": mejor_score,
        "debug_scores": scores
    }


def mostrar_deteccion(deteccion):
    """
    Muestra el resultado de detecciÃ³n de forma visual
    """
    print(f"\n{'=' * 70}")
    print("ğŸ” DETECCIÃ“N DE DOCUMENTO")
    print(f"{'=' * 70}\n")

    tipo = deteccion["tipo"]
    confianza = deteccion["confianza"]

    if tipo == "DESCONOCIDO":
        print("âŒ NO SE PUDO IDENTIFICAR EL DOCUMENTO")
        print("\nğŸ“Š Scores de detecciÃ³n (debug):")
        for t, s in deteccion["debug_scores"].items():
            print(f"   {t}: {s} puntos")
        print("\nğŸ’¡ Posibles causas:")
        print("   - Imagen muy borrosa")
        print("   - Documento parcialmente visible")
        print("   - Tipo de documento no soportado")
        return

    # Emoji segÃºn tipo
    emojis = {
        "DNI_AZUL": "ğŸ”µ",
        "DNI_ELECTRONICO": "ğŸ†•",
        "CARNET_EXTRANJERIA": "ğŸŒ",
        "PASAPORTE_PERUANO": "ğŸ‡µğŸ‡ª",
        "PASAPORTE_EXTRANJERO": "ğŸ›‚"
    }

    emoji = emojis.get(tipo, "ğŸ“„")

    print(f"{emoji} TIPO: {tipo.replace('_', ' ')}")
    print(f"ğŸ“Š CONFIANZA: {confianza*100:.1f}%")
    print(f"ğŸ“Š SCORE: {deteccion['score']} puntos")
    print(f"ğŸ¨ COLOR: {deteccion.get('color', 'N/A')}")
    print(f"ğŸŒ PAÃS: {deteccion.get('pais', 'N/A')}")

    # Mostrar scores de debug
    print(f"\nğŸ“Š Scores de todos los tipos:")
    for t, s in deteccion["debug_scores"].items():
        simbolo = "âœ…" if t == tipo else "  "
        print(f"   {simbolo} {t}: {s} puntos")

    # Indicar si necesita reverso
    necesita_reverso = tipo in ["DNI_AZUL", "DNI_ELECTRONICO", "CARNET_EXTRANJERIA"]

    if necesita_reverso:
        print(f"\nâš ï¸  REQUIERE FOTO DEL REVERSO")
        print("   (Para obtener direcciÃ³n completa)")
    else:
        print(f"\nâœ… NO REQUIERE REVERSO")
        print("   (Todos los datos estÃ¡n en una sola pÃ¡gina)")

    print(f"\n{'=' * 70}")


print("âœ… Detector de documentos mejorado (v2.0)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 1: DNI (VERSIÃ“N v4.4 - ESTADO CIVIL CORREGIDO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_dni(texto_ocr, tipo_dni="DNI_AZUL"):
    """
    Extrae campos de DNI con estado civil corregido
    """
    import re
    datos = {}

    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    def buscar_indice(palabra_clave):
        for i, linea in enumerate(lineas):
            if re.search(palabra_clave, linea, re.IGNORECASE):
                return i
        return -1

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CUI Y DNI
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    cui_match = re.search(r'CUI[:\s]*(\d{8}[-\s]?\d)', texto_ocr, re.IGNORECASE)
    if cui_match:
        cui_completo = cui_match.group(1).replace(' ', '-')
        datos["cui"] = cui_completo
        datos["dni"] = cui_completo.split("-")[0]

    if "dni" not in datos:
        dni_matches = re.findall(r'\b(\d{8})\b', texto_ocr)
        for match in dni_matches:
            if not match.startswith(('01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31')):
                datos["dni"] = match
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_ap1 = buscar_indice(r'Primer\s*Apellido')
    if idx_ap1 >= 0 and idx_ap1 + 1 < len(lineas):
        datos["apellido_paterno"] = lineas[idx_ap1 + 1]

    idx_ap2 = buscar_indice(r'Segundo\s*Apellido')
    if idx_ap2 >= 0 and idx_ap2 + 1 < len(lineas):
        datos["apellido_materno"] = lineas[idx_ap2 + 1]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PRENOMBRES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_prenombres = buscar_indice(r'Prenombres?')

    if idx_prenombres >= 0:
        for i in range(idx_prenombres - 1, max(idx_prenombres - 4, -1), -1):
            linea = lineas[i]
            if re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]{10,}$', linea):
                if linea not in [datos.get("apellido_paterno"), datos.get("apellido_materno")]:
                    if not re.search(r'(Apellido|BENAVENTE|RIVADENEIRA|REGISTRO|REPUBLICA)', linea, re.IGNORECASE):
                        nombres = linea

                        if len(nombres.replace(' ', '')) > 15:
                            nombres = re.sub(
                                r'(MARIA|MONICA|MILAGROS|JUAN|JOSE|LUIS|CARLOS|PEDRO|ANA|ROSA|CARMEN|TERESA|ISABEL|GLORIA|PATRICIA|ALEJANDRA|FERNANDA|CAROLINA|DANIELA|ANDREA|CLAUDIA|VALENTINA|SOFIA|CAMILA|GABRIELA)',
                                r'\1 ',
                                nombres
                            ).strip()

                        nombres = re.sub(r'\s+', ' ', nombres)
                        datos["nombres"] = nombres
                        break

    if all(k in datos for k in ["nombres", "apellido_paterno", "apellido_materno"]):
        datos["nombre_completo"] = (
            f"{datos['nombres']} "
            f"{datos['apellido_paterno']} "
            f"{datos['apellido_materno']}"
        )

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    fnac_match = re.search(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', texto_ocr)
    if fnac_match:
        dia, mes, anio = fnac_match.groups()
        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"

        from datetime import datetime
        try:
            hoy = datetime.now()
            fecha_nac = datetime(int(anio), int(mes), int(dia))
            edad = (hoy - fecha_nac).days // 365
            datos["edad"] = edad
        except:
            pass

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SEXO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    sexo_match = re.search(r'Sexo[:\s]*\n?\s*([MF])\b', texto_ocr, re.IGNORECASE)
    if sexo_match:
        datos["sexo"] = sexo_match.group(1).upper()
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NACIONALIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    nac_match = re.search(r'Nacionalidad[:\s]*\n?\s*([A-Z]{3})\b', texto_ocr, re.IGNORECASE)
    if nac_match:
        codigo = nac_match.group(1).upper()
        datos["nacionalidad"] = "PERUANA" if codigo == "PER" else codigo

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ESTADO CIVIL (CORREGIDO)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    estados_validos = ["SOLTERO", "SOLTERA", "CASADO", "CASADA", "DIVORCIADO", "DIVORCIADA", "VIUDO", "VIUDA"]

    # Estrategia 1: Buscar cerca de "Estado Civil"
    idx_estado = buscar_indice(r'Estado\s*Civil')
    if idx_estado >= 0:
        # Buscar en las siguientes 3 lÃ­neas
        for i in range(idx_estado + 1, min(idx_estado + 4, len(lineas))):
            candidato = lineas[i].upper().strip()
            if candidato in estados_validos:
                datos["estado_civil"] = candidato
                break

    # Estrategia 2: Buscar directamente en todo el texto
    if "estado_civil" not in datos:
        texto_upper = texto_ocr.upper()
        for estado in estados_validos:
            if estado in texto_upper:
                datos["estado_civil"] = estado
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHAS DE EMISIÃ“N Y CADUCIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_emision = buscar_indice(r'Emisi[oÃ³]n')
    if idx_emision >= 0 and idx_emision + 1 < len(lineas):
        emision_str = lineas[idx_emision + 1]
        if re.match(r'^\d{8}$', emision_str):
            dia = emision_str[0:2]
            mes = emision_str[2:4]
            anio = emision_str[4:8]
            datos["fecha_emision"] = f"{dia}/{mes}/{anio}"

    idx_cad = buscar_indice(r'Caducidad')
    if idx_cad >= 0:
        for i in range(idx_cad, min(idx_cad + 2, len(lineas))):
            cad_match = re.search(r'(\d{8})', lineas[i])
            if cad_match:
                cad_str = cad_match.group(1)
                dia = cad_str[0:2]
                mes = cad_str[2:4]
                anio = cad_str[4:8]
                datos["fecha_caducidad"] = f"{dia}/{mes}/{anio}"
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # UBIGEO (REVERSO)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_depto = buscar_indice(r'Departamento|Depto')
    if idx_depto >= 0 and idx_depto + 1 < len(lineas):
        datos["departamento"] = lineas[idx_depto + 1]

    idx_prov = buscar_indice(r'Provincia')
    if idx_prov >= 0 and idx_prov + 1 < len(lineas):
        datos["provincia"] = lineas[idx_prov + 1]

    idx_dist = buscar_indice(r'Distrito')
    if idx_dist >= 0 and idx_dist + 1 < len(lineas):
        distrito = lineas[idx_dist + 1]
        if "-" in distrito:
            partes = distrito.split("-")
            if "provincia" not in datos:
                datos["provincia"] = partes[0].strip()
            datos["distrito"] = partes[1].strip()
        else:
            datos["distrito"] = distrito

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DIRECCIÃ“N (REVERSO)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_dir = buscar_indice(r'Direcci[oÃ³]n')
    if idx_dir >= 0 and idx_dir + 1 < len(lineas):
        direccion = lineas[idx_dir + 1]
        if len(direccion) > 10:
            datos["direccion"] = direccion

    return datos


print("âœ… Parser DNI v4.4 (estado civil corregido)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 2: CARNET DE EXTRANJERÃA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_carnet_extranjeria(texto_ocr):
    """
    Extrae campos del Carnet de ExtranjerÃ­a
    """
    import re
    datos = {}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NÃšMERO CE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ce_match = re.search(
        r'(?:N[Â°Âº]?|No\.?|CARNÃ‰ DE EXTRANJERÃA)\s*(\d{9,10})',
        texto_ocr,
        re.IGNORECASE
    )
    if ce_match:
        datos["numero_ce"] = ce_match.group(1)
        datos["dni"] = ce_match.group(1)  # Para compatibilidad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    apellidos_match = re.search(
        r'Apellidos?[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if apellidos_match:
        apellidos_completos = apellidos_match.group(1).strip()
        apellidos = apellidos_completos.split()

        if len(apellidos) >= 2:
            datos["apellido_paterno"] = apellidos[0]
            datos["apellido_materno"] = " ".join(apellidos[1:])
        else:
            datos["apellido_paterno"] = apellidos_completos

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NOMBRES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    nombres_match = re.search(
        r'Nombr(?:e|es)?[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nombres_match:
        datos["nombres"] = nombres_match.group(1).strip()

    # Nombre completo
    if "nombres" in datos and "apellido_paterno" in datos:
        ap_mat = datos.get("apellido_materno", "")
        datos["nombre_completo"] = (
            f"{datos['nombres']} "
            f"{datos['apellido_paterno']} "
            f"{ap_mat}"
        ).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NACIONALIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    nac_match = re.search(
        r'Nacionalidad[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nac_match:
        datos["nacionalidad"] = nac_match.group(1).upper()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO (formato: 09 JUN 1990)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    fnac_match = re.search(
        r'Fecha Nac[:\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
        texto_ocr,
        re.IGNORECASE
    )
    if fnac_match:
        dia, mes_txt, anio = fnac_match.groups()

        # Convertir mes texto â†’ nÃºmero
        MESES = {
            "ENE": "01", "FEB": "02", "MAR": "03", "ABR": "04",
            "MAY": "05", "JUN": "06", "JUL": "07", "AGO": "08",
            "SEP": "09", "SET": "09", "OCT": "10", "NOV": "11", "DIC": "12"
        }
        mes = MESES.get(mes_txt.upper(), "01")

        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"

        # Calcular edad
        from datetime import datetime
        hoy = datetime.now()
        fecha_nac = datetime(int(anio), int(mes), int(dia))
        edad = (hoy - fecha_nac).days // 365
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SEXO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sexo_match = re.search(r'Sexo[:\s]*([MF])', texto_ocr, re.IGNORECASE)
    if sexo_match:
        datos["sexo"] = sexo_match.group(1).upper()
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CALIDAD MIGRATORIA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    calidad_match = re.search(
        r'Calidad Migratoria[:\s]*([A-Z\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if calidad_match:
        datos["calidad_migratoria"] = calidad_match.group(1).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # UBIGEO (Departamento, Provincia, Distrito)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    depto_match = re.search(
        r'Departamento[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if depto_match:
        datos["departamento"] = depto_match.group(1).strip()

    prov_match = re.search(
        r'Provincia[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if prov_match:
        datos["provincia"] = prov_match.group(1).strip()

    dist_match = re.search(
        r'Distrito[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if dist_match:
        datos["distrito"] = dist_match.group(1).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DIRECCIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    dir_match = re.search(
        r'Direcci[oÃ³]n[:\s]*\n?\s*([A-Z0-9\s\.,\-Â°Âº]+)',
        texto_ocr,
        re.IGNORECASE | re.MULTILINE
    )
    if dir_match:
        datos["direccion"] = dir_match.group(1).strip()

    return datos


print("âœ… Parser de Carnet de ExtranjerÃ­a listo")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 3: PASAPORTES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_pasaporte(texto_ocr):
    """
    Extrae campos de pasaportes (peruanos o extranjeros)
    Usa la zona MRZ (Machine Readable Zone) para mÃ¡xima precisiÃ³n
    """
    import re
    datos = {}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODO 1: ZONA MRZ (mÃ¡s confiable)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # MRZ LÃ­nea 1: P<CODAPELLIDO<<NOMBRES<<<<<<<<<<<
    mrz_linea1 = re.search(
        r'P<([A-Z]{3})([A-Z<]+)<<([A-Z<]+)',
        texto_ocr
    )

    if mrz_linea1:
        codigo_pais = mrz_linea1.group(1)
        apellidos_mrz = mrz_linea1.group(2).replace("<", " ").strip()
        nombres_mrz = mrz_linea1.group(3).replace("<", " ").strip()

        datos["codigo_pais"] = codigo_pais
        datos["apellidos"] = apellidos_mrz
        datos["nombres"] = nombres_mrz
        datos["nombre_completo"] = f"{nombres_mrz} {apellidos_mrz}"

    # MRZ LÃ­nea 2: NUMERO123CODYYMMDDSFYYMMDD<<<<<<<<
    mrz_linea2 = re.search(
        r'(\w{9})(\d?)([A-Z]{3})(\d{2})(\d{2})(\d{2})([MF])(\d{2})(\d{2})(\d{2})',
        texto_ocr
    )

    if mrz_linea2:
        numero = mrz_linea2.group(1)
        pais = mrz_linea2.group(3)
        anio_nac = mrz_linea2.group(4)
        mes_nac = mrz_linea2.group(5)
        dia_nac = mrz_linea2.group(6)
        sexo = mrz_linea2.group(7)
        anio_venc = mrz_linea2.group(8)
        mes_venc = mrz_linea2.group(9)
        dia_venc = mrz_linea2.group(10)

        datos["numero_pasaporte"] = numero
        datos["dni"] = numero
        datos["sexo"] = sexo
        datos["sexo_completo"] = "MASCULINO" if sexo == "M" else "FEMENINO"

        # Convertir fechas YY â†’ YYYY
        anio_nac_completo = f"19{anio_nac}" if int(anio_nac) > 25 else f"20{anio_nac}"
        anio_venc_completo = f"20{anio_venc}"

        datos["fecha_nacimiento"] = f"{dia_nac}/{mes_nac}/{anio_nac_completo}"
        datos["fecha_nacimiento_iso"] = f"{anio_nac_completo}-{mes_nac}-{dia_nac}"
        datos["fecha_vencimiento"] = f"{dia_venc}/{mes_venc}/{anio_venc_completo}"

        # Calcular edad
        from datetime import datetime
        hoy = datetime.now()
        fecha_nac = datetime(int(anio_nac_completo), int(mes_nac), int(dia_nac))
        edad = (hoy - fecha_nac).days // 365
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODO 2: TEXTO VISIBLE (complementario)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # NÃºmero de Pasaporte (si no se extrajo de MRZ)
    if "numero_pasaporte" not in datos:
        num_match = re.search(
            r'(?:Passport No|N[Â°Âº]? Pasaporte)[:\.\s]*([A-Z0-9]{7,9})',
            texto_ocr,
            re.IGNORECASE
        )
        if num_match:
            datos["numero_pasaporte"] = num_match.group(1)
            datos["dni"] = num_match.group(1)

    # Apellidos
    if "apellidos" not in datos:
        apellidos_match = re.search(
            r'(?:Surname|Apellidos?)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
            texto_ocr,
            re.IGNORECASE
        )
        if apellidos_match:
            datos["apellidos"] = apellidos_match.group(1).strip()

    # Nombres
    if "nombres" not in datos:
        nombres_match = re.search(
            r'(?:Given Names?|Nombres?)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
            texto_ocr,
            re.IGNORECASE
        )
        if nombres_match:
            datos["nombres"] = nombres_match.group(1).strip()

    # Nombre completo
    if "nombre_completo" not in datos:
        if "nombres" in datos and "apellidos" in datos:
            datos["nombre_completo"] = f"{datos['nombres']} {datos['apellidos']}"

    # Nacionalidad
    nac_match = re.search(
        r'(?:Nationality|Nacionalidad)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nac_match:
        datos["nacionalidad"] = nac_match.group(1).strip()

    # Fecha de Nacimiento (si no se extrajo de MRZ)
    if "fecha_nacimiento" not in datos:
        fnac_match = re.search(
            r'(?:Date of Birth|Fecha de Nacimiento)[:\.\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
            texto_ocr,
            re.IGNORECASE
        )
        if fnac_match:
            dia, mes_txt, anio = fnac_match.groups()

            MESES = {
                "JAN": "01", "FEB": "02", "MAR": "03", "APR": "04",
                "MAY": "05", "JUN": "06", "JUL": "07", "AUG": "08",
                "SEP": "09", "OCT": "10", "NOV": "11", "DEC": "12"
            }
            mes = MESES.get(mes_txt.upper(), "01")

            datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
            datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"

    # Lugar de Nacimiento
    lugar_match = re.search(
        r'(?:Place of Birth|Lugar de Nacimiento)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s\-,]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if lugar_match:
        datos["lugar_nacimiento"] = lugar_match.group(1).strip()

    # Fecha de ExpediciÃ³n
    emision_match = re.search(
        r'(?:Date of Issue|Fecha de Expedici[oÃ³]n)[:\.\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
        texto_ocr,
        re.IGNORECASE
    )
    if emision_match:
        dia, mes_txt, anio = emision_match.groups()
        MESES = {
            "JAN": "01", "FEB": "02", "MAR": "03", "APR": "04",
            "MAY": "05", "JUN": "06", "JUL": "07", "AUG": "08",
            "SEP": "09", "OCT": "10", "NOV": "11", "DEC": "12"
        }
        mes = MESES.get(mes_txt.upper(), "01")
        datos["fecha_emision"] = f"{dia}/{mes}/{anio}"

    # Sexo (si no se extrajo de MRZ)
    if "sexo" not in datos:
        sexo_match = re.search(r'(?:Sex|Sexo)[:\.\s]*([MF])', texto_ocr, re.IGNORECASE)
        if sexo_match:
            datos["sexo"] = sexo_match.group(1).upper()
            datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    return datos


print("âœ… Parser de Pasaportes listo")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N PRINCIPAL: PROCESAR CUALQUIER DOCUMENTO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def procesar_documento(imagen_frente, imagen_reverso=None, mejorar_calidad=True):
    """
    FUNCIÃ“N MAESTRA que procesa cualquier documento peruano

    Workflow:
    1. EvalÃºa calidad de la imagen
    2. Mejora la imagen si es necesario (fotocopias)
    3. Aplica OCR
    4. Detecta tipo de documento
    5. Extrae datos especÃ­ficos segÃºn el tipo
    6. Procesa reverso si es necesario
    7. Retorna datos estructurados

    Args:
        imagen_frente: str (ruta) o bytes (archivo)
        imagen_reverso: str (ruta) o bytes (archivo), opcional
        mejorar_calidad: bool - Si debe mejorar automÃ¡ticamente la imagen

    Returns:
        dict: {
            "exito": bool,
            "tipo": str,
            "confianza": float,
            "necesita_reverso": bool,
            "datos": dict,
            "calidad_imagen": dict,
            "errores": list
        }
    """
    print("\n" + "=" * 70)
    print("ğŸš€ INICIANDO PROCESAMIENTO DE DOCUMENTO")
    print("=" * 70)

    errores = []

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 1: Cargar imagen del frente
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ“¸ Cargando imagen del frente...")

    try:
        img_frente = cargar_imagen(imagen_frente)
        if img_frente is None:
            return {
                "exito": False,
                "error": "No se pudo cargar la imagen del frente",
                "errores": ["Imagen corrupta o formato no soportado"]
            }
        print(f"   âœ… Imagen cargada: {img_frente.shape[1]}x{img_frente.shape[0]} px")
    except Exception as e:
        return {
            "exito": False,
            "error": f"Error al cargar imagen: {str(e)}",
            "errores": [str(e)]
        }

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 2: Evaluar calidad de la imagen
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ” Evaluando calidad de imagen...")

    calidad = detectar_calidad_imagen(img_frente)

    print(f"   ğŸ“Š Contraste: {calidad['contraste']:.1f}")
    print(f"   ğŸ“Š Nitidez: {calidad['nitidez']:.1f}")
    print(f"   ğŸ“Š Calidad: {calidad['calidad']}")

    if calidad['es_fotocopia']:
        print(f"   ğŸ“„ Fotocopia detectada")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 3: Mejorar imagen si es necesario
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if mejorar_calidad and calidad['calidad'] in ['REGULAR', 'MALA']:
        print("\nâš™ï¸  Mejorando calidad de imagen...")
        img_procesada = mejorar_imagen_para_ocr(img_frente)
        print("   âœ… Imagen mejorada (contraste + nitidez)")
    else:
        img_procesada = img_frente
        print("\nâœ… Imagen con calidad suficiente, no requiere mejora")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 4: Aplicar OCR al frente
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ¤– Aplicando OCR al frente del documento...")

    try:
        resultado_ocr = ocr_engine.ocr(img_procesada, cls=True)
        texto_frente = extraer_texto_limpio(resultado_ocr)

        if not texto_frente:
            errores.append("No se detectÃ³ texto en la imagen")
            return {
                "exito": False,
                "error": "No se detectÃ³ texto legible",
                "errores": errores,
                "calidad_imagen": calidad
            }

        print(f"   âœ… OCR completado: {len(texto_frente)} caracteres extraÃ­dos")

    except Exception as e:
        errores.append(f"Error en OCR: {str(e)}")
        return {
            "exito": False,
            "error": "Error al aplicar OCR",
            "errores": errores
        }

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 5: Detectar tipo de documento
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ” Detectando tipo de documento...")

    deteccion = detectar_tipo_documento(texto_frente)

    if deteccion["tipo"] == "DESCONOCIDO":
        errores.append("No se pudo identificar el tipo de documento")
        print("\nâŒ Tipo de documento no reconocido")
        print("\nğŸ“„ Texto extraÃ­do (primeros 500 caracteres):")
        print("-" * 70)
        print(texto_frente[:500])
        print("-" * 70)

        return {
            "exito": False,
            "error": "Tipo de documento no reconocido",
            "errores": errores,
            "texto_extraido": texto_frente,
            "calidad_imagen": calidad
        }

    mostrar_deteccion(deteccion)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 6: Parsear datos segÃºn el tipo
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ“ Extrayendo datos del documento...")

    tipo = deteccion["tipo"]

    try:
        if tipo in ["DNI_AZUL", "DNI_ELECTRONICO"]:
            datos = parsear_dni(texto_frente, tipo)
        elif tipo == "CARNET_EXTRANJERIA":
            datos = parsear_carnet_extranjeria(texto_frente)
        elif tipo in ["PASAPORTE_PERUANO", "PASAPORTE_EXTRANJERO"]:
            datos = parsear_pasaporte(texto_frente)
        else:
            datos = {}

        print(f"   âœ… {len(datos)} campos extraÃ­dos del frente")

    except Exception as e:
        errores.append(f"Error al parsear datos: {str(e)}")
        datos = {}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 7: Procesar reverso si existe y es necesario
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    necesita_reverso = tipo in ["DNI_AZUL", "DNI_ELECTRONICO", "CARNET_EXTRANJERIA"]

    if imagen_reverso and necesita_reverso:
        print("\nğŸ“¸ Procesando reverso del documento...")

        try:
            # Cargar imagen del reverso
            img_reverso = cargar_imagen(imagen_reverso)

            # Mejorar si es necesario
            if mejorar_calidad and calidad['calidad'] in ['REGULAR', 'MALA']:
                img_reverso = mejorar_imagen_para_ocr(img_reverso)

            # OCR del reverso
            resultado_ocr_rev = ocr_engine.ocr(img_reverso, cls=True)
            texto_reverso = extraer_texto_limpio(resultado_ocr_rev)

            # Parsear reverso
            if tipo in ["DNI_AZUL", "DNI_ELECTRONICO"]:
                datos_reverso = parsear_dni(texto_reverso, tipo)
            elif tipo == "CARNET_EXTRANJERIA":
                datos_reverso = parsear_carnet_extranjeria(texto_reverso)

            # COMBINAR datos (reverso complementa al frente)
            datos.update(datos_reverso)

            print(f"   âœ… Reverso procesado: {len(datos)} campos totales")

        except Exception as e:
            errores.append(f"Error al procesar reverso: {str(e)}")
            print(f"   âš ï¸  Error al procesar reverso: {str(e)}")

    elif necesita_reverso and not imagen_reverso:
        print(f"\nâš ï¸  ADVERTENCIA: Este documento requiere foto del reverso")
        print("   Algunos campos pueden estar incompletos (ej: direcciÃ³n)")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 8: Validar datos extraÃ­dos
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nâœ… Validando datos extraÃ­dos...")

    campos_requeridos = ["nombre_completo", "dni", "fecha_nacimiento"]
    campos_faltantes = [c for c in campos_requeridos if c not in datos or not datos[c]]

    if campos_faltantes:
        print(f"   âš ï¸  Campos faltantes: {', '.join(campos_faltantes)}")
        errores.append(f"Campos faltantes: {', '.join(campos_faltantes)}")
    else:
        print(f"   âœ… Todos los campos principales extraÃ­dos correctamente")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PASO 9: Retornar resultado
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    exito = len(campos_faltantes) == 0

    print("\n" + "=" * 70)
    if exito:
        print("âœ… PROCESAMIENTO COMPLETADO CON Ã‰XITO")
    else:
        print("âš ï¸  PROCESAMIENTO COMPLETADO CON ADVERTENCIAS")
    print("=" * 70)

    return {
        "exito": exito,
        "tipo": deteccion["tipo"],
        "formato": deteccion.get("formato"),
        "pais": deteccion.get("pais"),
        "confianza": deteccion["confianza"],
        "necesita_reverso": necesita_reverso,
        "datos": datos,
        "calidad_imagen": calidad,
        "errores": errores if errores else None,
        "texto_extraido": texto_frente  # Para debug
    }


print("âœ… FunciÃ³n principal lista")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VISUALIZACIÃ“N DE RESULTADOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def mostrar_resultados(resultado):
    """
    Muestra los resultados del procesamiento de forma visual y organizada
    """
    print("\n" + "â•" * 70)
    print("ğŸ“Š RESULTADOS DEL PROCESAMIENTO")
    print("â•" * 70)

    if not resultado["exito"]:
        print("\nâŒ PROCESAMIENTO FALLIDO")
        if "error" in resultado:
            print(f"   Error: {resultado['error']}")
        if resultado.get("errores"):
            print("\n   Detalles:")
            for error in resultado["errores"]:
                print(f"   â€¢ {error}")
        return

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INFORMACIÃ“N DEL DOCUMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ“„ TIPO DE DOCUMENTO")
    print("-" * 70)
    print(f"   Tipo: {resultado['tipo'].replace('_', ' ')}")
    print(f"   PaÃ­s: {resultado.get('pais', 'N/A')}")
    print(f"   Confianza: {resultado['confianza']*100:.1f}%")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATOS PERSONALES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    datos = resultado["datos"]

    print("\nğŸ‘¤ DATOS PERSONALES")
    print("-" * 70)

    if "nombre_completo" in datos:
        print(f"   Nombre Completo: {datos['nombre_completo']}")

    if "nombres" in datos:
        print(f"   Nombres: {datos['nombres']}")
    if "apellido_paterno" in datos:
        print(f"   Apellido Paterno: {datos['apellido_paterno']}")
    if "apellido_materno" in datos:
        print(f"   Apellido Materno: {datos['apellido_materno']}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DOCUMENTO DE IDENTIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ†” DOCUMENTO DE IDENTIDAD")
    print("-" * 70)

    if "dni" in datos:
        print(f"   DNI/NÃºmero: {datos['dni']}")
    if "cui" in datos:
        print(f"   CUI: {datos['cui']}")
    if "numero_ce" in datos:
        print(f"   NÂ° CE: {datos['numero_ce']}")
    if "numero_pasaporte" in datos:
        print(f"   NÂ° Pasaporte: {datos['numero_pasaporte']}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATOS DEMOGRÃFICOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    print("\nğŸ“… DATOS DEMOGRÃFICOS")
    print("-" * 70)

    if "fecha_nacimiento" in datos:
        print(f"   Fecha de Nacimiento: {datos['fecha_nacimiento']}")
    if "edad" in datos:
        print(f"   Edad: {datos['edad']} aÃ±os")
    if "sexo_completo" in datos:
        print(f"   Sexo: {datos['sexo_completo']}")
    elif "sexo" in datos:
        print(f"   Sexo: {datos['sexo']}")
    if "nacionalidad" in datos:
        print(f"   Nacionalidad: {datos['nacionalidad']}")
    if "estado_civil" in datos:
        print(f"   Estado Civil: {datos['estado_civil']}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # UBICACIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if any(k in datos for k in ["departamento", "provincia", "distrito", "direccion"]):
        print("\nğŸ“ UBICACIÃ“N")
        print("-" * 70)

        if "departamento" in datos:
            print(f"   Departamento: {datos['departamento']}")
        if "provincia" in datos:
            print(f"   Provincia: {datos['provincia']}")
        if "distrito" in datos:
            print(f"   Distrito: {datos['distrito']}")
        if "direccion" in datos:
            print(f"   DirecciÃ³n: {datos['direccion']}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DATOS ADICIONALES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    datos_adicionales = {}

    if "calidad_migratoria" in datos:
        datos_adicionales["Calidad Migratoria"] = datos["calidad_migratoria"]
    if "lugar_nacimiento" in datos:
        datos_adicionales["Lugar de Nacimiento"] = datos["lugar_nacimiento"]
    if "fecha_emision" in datos:
        datos_adicionales["Fecha de EmisiÃ³n"] = datos["fecha_emision"]
    if "fecha_vencimiento" in datos:
        datos_adicionales["Fecha de Vencimiento"] = datos["fecha_vencimiento"]

    if datos_adicionales:
        print("\nğŸ“‹ DATOS ADICIONALES")
        print("-" * 70)
        for key, value in datos_adicionales.items():
            print(f"   {key}: {value}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ADVERTENCIAS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if resultado.get("errores"):
        print("\nâš ï¸  ADVERTENCIAS")
        print("-" * 70)
        for error in resultado["errores"]:
            print(f"   â€¢ {error}")

    print("\n" + "â•" * 70)


print("âœ… FunciÃ³n de visualizaciÃ³n lista")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILIDAD: SUBIR ARCHIVOS EN COLAB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import io

def subir_imagenes():
    """
    Permite subir imÃ¡genes desde tu computadora a Colab

    Returns:
        dict: {
            "frente": bytes,
            "reverso": bytes (opcional)
        }
    """
    print("=" * 70)
    print("ğŸ“¤ SUBIR IMÃGENES")
    print("=" * 70)

    print("\nğŸ“¸ Selecciona la foto del FRENTE del documento:")
    print("   (DNI/Pasaporte/Carnet de ExtranjerÃ­a)")

    uploaded_frente = files.upload()

    if not uploaded_frente:
        print("âŒ No se subiÃ³ ninguna imagen")
        return None

    # Obtener el archivo subido
    filename_frente = list(uploaded_frente.keys())[0]
    imagen_frente = io.BytesIO(uploaded_frente[filename_frente])

    print(f"âœ… Frente subido: {filename_frente}")

    # Preguntar por el reverso
    print("\nÂ¿Este documento necesita foto del reverso?")
    print("   â€¢ DNI (azul o electrÃ³nico) â†’ SÃ")
    print("   â€¢ Carnet de ExtranjerÃ­a â†’ SÃ")
    print("   â€¢ Pasaporte â†’ NO")

    respuesta = input("\nÂ¿Subir reverso? (s/n): ").strip().lower()

    imagen_reverso = None

    if respuesta == 's':
        print("\nğŸ“¸ Selecciona la foto del REVERSO:")
        uploaded_reverso = files.upload()

        if uploaded_reverso:
            filename_reverso = list(uploaded_reverso.keys())[0]
            imagen_reverso = io.BytesIO(uploaded_reverso[filename_reverso])
            print(f"âœ… Reverso subido: {filename_reverso}")

    return {
        "frente": imagen_frente,
        "reverso": imagen_reverso
    }


print("âœ… FunciÃ³n de subida de archivos lista")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EJEMPLOS DE USO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("ğŸ¯ SISTEMA LISTO PARA USAR")
print("=" * 70)

print("\nğŸ“š MODOS DE USO:\n")

print("ğŸ”¹ OPCIÃ“N 1: Subir imÃ¡genes manualmente")
print("-" * 70)
print("""
# Ejecuta esta celda:
imagenes = subir_imagenes()

if imagenes:
    resultado = procesar_documento(
        imagen_frente=imagenes["frente"],
        imagen_reverso=imagenes["reverso"]
    )

    mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 2: Usar imÃ¡genes desde URL")
print("-" * 70)
print("""
# Descargar desde URL:
import urllib.request

url_frente = "https://ejemplo.com/dni_frente.jpg"
urllib.request.urlretrieve(url_frente, "dni_frente.jpg")

resultado = procesar_documento("dni_frente.jpg")
mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 3: Usar imÃ¡genes desde Google Drive")
print("-" * 70)
print("""
# 1) Montar Google Drive:
from google.colab import drive
drive.mount('/content/drive')

# 2) Procesar imagen desde Drive:
resultado = procesar_documento(
    imagen_frente="/content/drive/MyDrive/documentos/dni_frente.jpg",
    imagen_reverso="/content/drive/MyDrive/documentos/dni_reverso.jpg"
)

mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 4: Procesar mÃºltiples documentos")
print("-" * 70)
print("""
# Procesar 3 personas (Padre, Madre, Menor):

documentos = {
    "padre": {
        "frente": "padre_frente.jpg",
        "reverso": "padre_reverso.jpg"
    },
    "madre": {
        "frente": "madre_frente.jpg",
        "reverso": "madre_reverso.jpg"
    },
    "menor": {
        "frente": "menor_frente.jpg",
        "reverso": "menor_reverso.jpg"
    }
}

resultados = {}

for persona, imgs in documentos.items():
    print(f"\\n{'='*70}")
    print(f"ğŸ“„ Procesando: {persona.upper()}")
    print(f"{'='*70}")

    resultado = procesar_documento(
        imagen_frente=imgs["frente"],
        imagen_reverso=imgs["reverso"]
    )

    resultados[persona] = resultado
    mostrar_resultados(resultado)

# Ahora tienes todos los datos en 'resultados'
""")

print("\n" + "=" * 70)
print("ğŸ’¡ EJECUTA LA SIGUIENTE CELDA PARA EMPEZAR")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ DEMO INTERACTIVA - EJECUTA ESTA CELDA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ¬ INICIANDO DEMO INTERACTIVA\n")

# Subir imÃ¡genes
imagenes = subir_imagenes()

if imagenes:
    print("\n" + "ğŸ”„ " * 35)

    # Procesar documento
    resultado = procesar_documento(
        imagen_frente=imagenes["frente"],
        imagen_reverso=imagenes["reverso"],
        mejorar_calidad=True  # Mejorar automÃ¡ticamente si es fotocopia
    )

    # Mostrar resultados
    mostrar_resultados(resultado)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OPCIONES POST-PROCESAMIENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if resultado["exito"]:
        print("\n" + "=" * 70)
        print("âœ… Â¿QUÃ‰ QUIERES HACER CON ESTOS DATOS?")
        print("=" * 70)

        print("\n1ï¸âƒ£  Exportar como JSON")
        print("2ï¸âƒ£  Exportar como CSV")
        print("3ï¸âƒ£  Ver datos crudos (para debugging)")
        print("4ï¸âƒ£  Guardar en variable para usar despuÃ©s")

        # Exportar como JSON
        import json

        json_output = json.dumps(resultado["datos"], indent=2, ensure_ascii=False)

        print("\nğŸ“„ DATOS EN FORMATO JSON:")
        print("-" * 70)
        print(json_output)

        # Guardar en variable global
        datos_extraidos = resultado["datos"]

        print("\nâœ… Datos guardados en la variable: datos_extraidos")
        print("   Puedes acceder a ellos con: datos_extraidos['nombre_completo']")

else:
    print("\nâŒ No se subieron imÃ¡genes")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG: VER TEXTO RAW DEL OCR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import cv2
import numpy as np
from PIL import Image

print("ğŸ“¤ Sube la imagen del FRENTE:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

# Cargar imagen
img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Aplicar OCR
resultado = ocr_engine.ocr(img_rgb, cls=True)

# Extraer SOLO el texto
texto_completo = []
for bloque in resultado[0]:
    texto = bloque[1][0]
    texto_completo.append(texto)

texto_raw = '\n'.join(texto_completo)

print("=" * 70)
print("ğŸ“„ TEXTO RAW DEL OCR (lÃ­nea por lÃ­nea)")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# Guardar en archivo para anÃ¡lisis
with open('texto_ocr.txt', 'w', encoding='utf-8') as f:
    f.write(texto_raw)

print("\nâœ… Texto guardado en 'texto_ocr.txt'")
print("\nğŸ“‹ Copia este texto y envÃ­amelo para anÃ¡lisis")

# DEBUG REVERSO
from google.colab import files

print("ğŸ“¤ Sube la imagen del REVERSO (DNI02-523X250.jpg):")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

resultado = ocr_engine.ocr(img_rgb, cls=True)

texto_completo = []
for bloque in resultado[0]:
    texto = bloque[1][0]
    texto_completo.append(texto)

texto_raw = '\n'.join(texto_completo)

print("=" * 70)
print("ğŸ“„ TEXTO RAW DEL REVERSO")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CÃ“DIGO PARA INTEGRAR EN TU APP STREAMLIT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

codigo_streamlit = '''
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTEGRACIÃ“N EN app.py (tu sistema actual)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import streamlit as st
from paddleocr import PaddleOCR
import cv2
import numpy as np

# Inicializar OCR (una sola vez, al inicio de la app)
@st.cache_resource
def cargar_ocr():
    return PaddleOCR(use_angle_cls=True, lang="es", use_gpu=False)

ocr_engine = cargar_ocr()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EN TU FORMULARIO DE PERMISOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

st.subheader("ğŸ‘¨ Datos del Padre")

# PestaÃ±as para elegir mÃ©todo
tab_ocr, tab_manual = st.tabs(["ğŸ“¸ Escanear DNI", "âŒ¨ï¸ Ingresar manualmente"])

with tab_ocr:
    st.caption("Sube fotos o fotocopias del DNI (ambos lados)")

    col1, col2 = st.columns(2)

    with col1:
        padre_frente = st.file_uploader(
            "Frente del DNI",
            type=["jpg", "jpeg", "png"],
            key="padre_frente"
        )
        if padre_frente:
            st.image(padre_frente, caption="Vista previa", width=200)

    with col2:
        padre_reverso = st.file_uploader(
            "Reverso del DNI",
            type=["jpg", "jpeg", "png"],
            key="padre_reverso"
        )
        if padre_reverso:
            st.image(padre_reverso, caption="Vista previa", width=200)

    if st.button("ğŸ” Extraer datos automÃ¡ticamente", key="btn_padre"):
        if padre_frente:
            with st.spinner("Procesando documento..."):
                # AQUÃ LLAMAS A TU FUNCIÃ“N procesar_documento()
                resultado = procesar_documento(
                    imagen_frente=padre_frente,
                    imagen_reverso=padre_reverso
                )

                if resultado["exito"]:
                    st.success(f"âœ… Documento procesado: {resultado['tipo']}")

                    # PRE-LLENAR CAMPOS DEL FORMULARIO
                    datos = resultado["datos"]

                    st.session_state["padre_nombre"] = datos.get("nombre_completo", "")
                    st.session_state["padre_dni"] = datos.get("dni", "")
                    st.session_state["padre_fnac"] = datos.get("fecha_nacimiento", "")
                    st.session_state["padre_sexo"] = datos.get("sexo", "")
                    st.session_state["padre_departamento"] = datos.get("departamento", "")
                    st.session_state["padre_provincia"] = datos.get("provincia", "")
                    st.session_state["padre_distrito"] = datos.get("distrito", "")
                    st.session_state["padre_direccion"] = datos.get("direccion", "")

                    st.rerun()  # Recargar para mostrar campos pre-llenados

                else:
                    st.error(f"âŒ {resultado['error']}")
                    st.info("ğŸ’¡ Intenta con mejor calidad de imagen o usa ingreso manual")
        else:
            st.warning("âš ï¸ Debes subir al menos la foto del frente")

with tab_manual:
    # Tu formulario actual (sin cambios)
    padre_nombre = st.text_input(
        "Nombre completo del padre",
        value=st.session_state.get("padre_nombre", "")
    )
    padre_dni = st.text_input(
        "DNI del padre",
        value=st.session_state.get("padre_dni", "")
    )
    # ... resto de campos

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPETIR LO MISMO PARA MADRE Y MENOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
'''

print("=" * 70)
print("ğŸ’» CÃ“DIGO PARA INTEGRAR EN TU STREAMLIT")
print("=" * 70)
print(codigo_streamlit)

# Guardar en archivo
with open("integracion_streamlit.py", "w", encoding="utf-8") as f:
    f.write(codigo_streamlit)

print("\nâœ… CÃ³digo guardado en: integracion_streamlit.py")
print("   Puedes descargarlo y copiarlo a tu app.py")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANALIZAR RENDIMIENTO Y PRECISIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generar_reporte(resultados_lista):
    """
    Genera reporte de mÃºltiples procesamientos

    Args:
        resultados_lista: list de resultados de procesar_documento()
    """
    print("\n" + "=" * 70)
    print("ğŸ“Š REPORTE DE PROCESAMIENTO")
    print("=" * 70)

    total = len(resultados_lista)
    exitosos = sum(1 for r in resultados_lista if r["exito"])
    fallidos = total - exitosos

    print(f"\nğŸ“ˆ RESUMEN GENERAL")
    print("-" * 70)
    print(f"   Total procesados: {total}")
    print(f"   âœ… Exitosos: {exitosos} ({exitosos/total*100:.1f}%)")
    print(f"   âŒ Fallidos: {fallidos} ({fallidos/total*100:.1f}%)")

    # Tipos de documentos
    tipos = {}
    for r in resultados_lista:
        if r.get("tipo"):
            tipo = r["tipo"]
            tipos[tipo] = tipos.get(tipo, 0) + 1

    print(f"\nğŸ“„ TIPOS DE DOCUMENTOS")
    print("-" * 70)
    for tipo, count in tipos.items():
        print(f"   {tipo.replace('_', ' ')}: {count}")

    # Confianza promedio
    confianzas = [r["confianza"] for r in resultados_lista if "confianza" in r]
    if confianzas:
        promedio = sum(confianzas) / len(confianzas)
        print(f"\nğŸ¯ CONFIANZA PROMEDIO: {promedio*100:.1f}%")

    # Calidad de imÃ¡genes
    calidades = [r["calidad_imagen"]["calidad"] for r in resultados_lista if "calidad_imagen" in r]
    if calidades:
        print(f"\nğŸ“¸ CALIDAD DE IMÃGENES")
        print("-" * 70)
        from collections import Counter
        conteo = Counter(calidades)
        for calidad, count in conteo.items():
            print(f"   {calidad}: {count}")


print("âœ… FunciÃ³n de reportes lista")